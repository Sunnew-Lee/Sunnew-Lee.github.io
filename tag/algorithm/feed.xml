<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="/tag/algorithm/feed.xml" rel="self" type="application/atom+xml" />
  <link href="/" rel="alternate" type="text/html" />
  <updated>2025-01-06T00:07:25+09:00</updated>
  <id>/tag/algorithm/feed.xml</id>

  
  
  

  
    <title type="html">Sunwoo Lee’s Blog | </title>
  

  
    <subtitle>My Personal Dev Blog</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">BOJ 17298) 오큰수</title>
      <link href="/algo_stack_4" rel="alternate" type="text/html" title="BOJ 17298) 오큰수" />
      <published>2025-01-04T04:12:00+09:00</published>
      <updated>2025-01-04T04:12:00+09:00</updated>
      <id>/algo_stack_4</id>
      <content type="html" xml:base="/algo_stack_4">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;크기가 n인 수열이 주어질때, 각 원소의 오른쪽에 있으면서 자신보다 큰 최초의 수를 각각 출력하는 문제이다. 만일 오른쪽에 자신보다 큰 수가 없다면 -1을 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;512&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 01.05.2025
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;vector&amp;gt;
using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int size, num;
    cin &amp;gt;&amp;gt; size;
    stack&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; stack; //num,index
    vector&amp;lt;int&amp;gt; out(size, -1);  //미리 -1로 초기화

    for (int i{ 0 }; i &amp;lt; size; i++)
    {
        cin &amp;gt;&amp;gt; num;
        while (!stack.empty() &amp;amp;&amp;amp; stack.top().first &amp;lt; num)
        {
            out[stack.top().second] = num;
            stack.pop();
        }

        stack.push({ num,i });
    }


    for (int i:out)
    {
        cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
    }


    return 0;
}
&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/fb46a6a798c0a1de34662177aec6fef6.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;위의 풀이 말고도 또 다른 풀이도 있다.&lt;/li&gt;
  &lt;li&gt;Monotonic Stack을 활용하는 문제.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;위의 풀이는 out 벡터를 모두 -1로 초기화시키고 시작해서 예외처리를 생략했다.
    &lt;ul&gt;
      &lt;li&gt;수열을 순차적으로 순회하면서 만일 새로 들어오는 수가 스택에 있는 수보다 크다면, 스택의 수 인덱스의 out 벡터에 새로 들어오는 수를 저장한다(새로 들어왔으니 자신보다 큰 최초의 수)&lt;/li&gt;
      &lt;li&gt;순차적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cin&lt;/code&gt;을 부르기 때문에, 메모리사용량이 상대적으로 적다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다른 풀이는, input 배열(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vector&lt;/code&gt;)를 만들어서 미리 수열을 모두 받고, 역순으로 순회한다.
    &lt;ul&gt;
      &lt;li&gt;새로 들어오는 수가 스택에 있는 수보다 크거나 같다면, 스택을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop&lt;/code&gt;한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt;문을 나오면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt;의 상황에 따라 output 벡터에 값을 저장하고 스택에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt;한다.&lt;/li&gt;
      &lt;li&gt;input을 모두 담을 메모리 비용이 추가적으로 들어간다.&lt;/li&gt;
      &lt;li&gt;스택에 더미를 넣고 시작할 수 있지만, 그렇다 하더라도 스택에 더미만 남는경우를 항상 체크해서 -1를 넣어줘야하기 때문에 불필요하다.&lt;/li&gt;
      &lt;li&gt;풀이를 보면 인풋과 아웃풋 벡터 2개를 만들지만 사실 인풋벡터 하나만 사용하는 방법도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;한가지 알게된 사실은 이런식으로 수열이 한문장에 와서 문제 푸는경우(단, 수가 매우 많은 edge case를 고려할때)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cin&lt;/code&gt; 계속 받는게 제일 느림&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sstringstream&lt;/code&gt;도 느림&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getline&lt;/code&gt;으로 한줄을 string에 다 받고, 하나하나 계산하면서 수 만들어서 저장하는게 가장 압도적으로 빠름.(2번풀이 인풋로직)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17298&quot;&gt;17298) 오큰수 풀러가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/source/70893612&quot;&gt;풀이 2 보러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 6198) 옥상 정원 꾸미기/Bad Hair Day</title>
      <link href="/algo_stack_3" rel="alternate" type="text/html" title="BOJ 6198) 옥상 정원 꾸미기/Bad Hair Day" />
      <published>2024-12-18T20:08:00+09:00</published>
      <updated>2024-12-18T20:08:00+09:00</updated>
      <id>/algo_stack_3</id>
      <content type="html" xml:base="/algo_stack_3">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;일렬로 나열된 n개의 빌딩 꼭대기에서 각각 오른쪽으로 볼 수있는 빌딩의 갯수를 더하는 문제이다. 단, 자신이 위치한 빌딩보다 높이가 높거나 같은 빌딩이 있으면 그 다음에 있는 모든 빌딩의 옥상은 보지 못한다.&lt;/li&gt;
  &lt;li&gt;원문인 영어로는 빌딩 대신 소(cow)로 표현되어있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;128&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 12.18.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int size, height;
	cin &amp;gt;&amp;gt; size;

	stack&amp;lt;int&amp;gt; heights;
	long long sum{ 0 };
	while (size--)
	{
		cin &amp;gt;&amp;gt; height;

		while (!heights.empty() &amp;amp;&amp;amp; heights.top() &amp;lt;= height)
		{
			heights.pop();
		}

		sum += heights.size();    //새롭게 만들어지는 쌍 수
		heights.push(height);
	}

	cout &amp;lt;&amp;lt; sum;

	return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/b6415b104e3edda7ea42ac78d8b3cc5e.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;위의 풀이를 포함해 전부 3개의 해답을 찾았다.&lt;/li&gt;
  &lt;li&gt;Monotonic Stack을 활용하는 문제이며, &lt;code&gt;&lt;a href=&quot;./algo_stack_2&quot;&gt;BOJ 2493) 탑&lt;/a&gt;&lt;/code&gt;의 응용판이라 볼 수 있다.&lt;/li&gt;
  &lt;li&gt;중요한 점은 &lt;strong&gt;하나의 탑이 볼 수 있는 탑의 개수는, 오른쪽으로 그 탑보다 높이가 작은 탑의 개수와 같다&lt;/strong&gt;는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;첫번째 풀이는 탑 문제와 비슷하게 푸는방법으로, 이전에는 가장 왼쪽 탑부터 순차적으로 풀었지만, 이번 문제는 오른쪽부터 풀기 위해 먼저 높이를 모두 입력받은 후, 오른쪽부터 순회한다.
    &lt;ul&gt;
      &lt;li&gt;더미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S.push({1000000001, n})&lt;/code&gt;를 스택에 추가해 줌으로써, 스택의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;empty()&lt;/code&gt; 확인 불필요 등, 여러 이점이 있다.&lt;/li&gt;
      &lt;li&gt;스택에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pair&amp;lt;height, index&amp;gt;&lt;/code&gt;를 저장하고, &lt;strong&gt;탑들을 오른쪽에서 왼쪽으로 순회&lt;/strong&gt;하면서 &lt;strong&gt;현재 탑보다 높은 탑들을 저장&lt;/strong&gt;한다.&lt;/li&gt;
      &lt;li&gt;그리하여 &lt;strong&gt;현재 건물보다 높은 탑의 인덱스와 현재 탑의 인덱스 차&lt;/strong&gt;를 이용하면, 현재 탑이 몇개의 탑을 내다볼 수 있는지 알 수 있게된다.
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S.top().Y&lt;/code&gt;는 현재 탑보다 높은 탑의 인덱스&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(i+1)&lt;/code&gt;은 현재 탑의 인덱스&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;두번째 풀이도 오른쪽부터 풀기 위해 높이를 모두 입력받고 오른쪽부터 순회하지만, 저장하는 정보가 다르다.
    &lt;ul&gt;
      &lt;li&gt;이번 풀이도 더미를 하나 추가해주고 시작한다.&lt;/li&gt;
      &lt;li&gt;스택에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pair&amp;lt;height, count&amp;gt;&lt;/code&gt;를 저장하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;는 &lt;strong&gt;이 탑의 오른쪽에 있는 자신보다 낮은 탑의 총 개수의 누적 수&lt;/strong&gt;이다다.&lt;/li&gt;
      &lt;li&gt;그러므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum += S.top().second&lt;/code&gt;는 pop되는 탑이 볼 수 있는 탑의 총 개수를 누적하는 과정이다.&lt;/li&gt;
      &lt;li&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count += S.top().second&lt;/code&gt;는 현재 건물보다 작은 건물들의 개수를 저장해서 나중에 스택에 push할때 두번째 인자로 사용할 변수에 누적하는 과정이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세번째 풀이는 위 두개의 풀이와 가장 차이가 많이 나는 풀이다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;탑을 왼쪽부터 순차적으로 순회&lt;/strong&gt;하며, 스택에는 &lt;strong&gt;탑의 높이 정보만 저장&lt;/strong&gt;한다.&lt;/li&gt;
      &lt;li&gt;현재 탑보다 높이가 작거나 같은 건물이 있다면 pop시킨다.&lt;/li&gt;
      &lt;li&gt;pop을 다 시킨 후, &lt;strong&gt;스택의 크기는 현재 높이보다 작은 탑들의 개수&lt;/strong&gt;를 나타내기 때문에 변수에 더해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;이 풀이에도 더미 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;heights.push(1000000001)&lt;/code&gt;를 넣어줄 수 있는데, 이 경우에 스택 크기를 더해줄때 항상 탑 하나의 개수를 빼줘야하며, 대신 조건문에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;empty()&lt;/code&gt;를 확인 할 필요가 없어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/6198&quot;&gt;6198) 옥상 정원 꾸미기/Bad Hair Day 풀러가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/source/49773300&quot;&gt;풀이 1 보러가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/source/61166866&quot;&gt;풀이 2 보러가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/source/88093532&quot;&gt;더미가 포함된 풀이 3 보러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 2493) 탑</title>
      <link href="/algo_stack_2" rel="alternate" type="text/html" title="BOJ 2493) 탑" />
      <published>2024-12-16T18:12:00+09:00</published>
      <updated>2024-12-16T18:12:00+09:00</updated>
      <id>/algo_stack_2</id>
      <content type="html" xml:base="/algo_stack_2">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;일렬로 나열된 n개의 탑 꼭대기에서 각각 왼쪽으로 각각 레이저를 발사할때, 레이저가 막히는(수신) 건물의 번호를 차례대로 출력하는 문제이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1.5&lt;/td&gt;
      &lt;td&gt;128&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 12.16.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
using namespace std;

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	int size, tower;
	cin &amp;gt;&amp;gt; size;
	stack&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; towers;	// pair&amp;lt;height,index&amp;gt;

	towers.push({ 100000001, 0 });	// Dummy 탑을 하나 만들어준다. 참고로 탑들의 최대 높이는 100000000 이다.

	for (int i{ 1 }; i &amp;lt;= size; i++)
	{
		cin &amp;gt;&amp;gt; tower;

		while (towers.top().first &amp;lt; tower)
			towers.pop();

		cout &amp;lt;&amp;lt; towers.top().second &amp;lt;&amp;lt; &amp;#39; &amp;#39;;
		towers.push({ tower, i });
	}

	return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/da5d071b6da883e0c2910cfdd66f1f60.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;처음으로 Monotonic Stack에 대해 알게 된 문제. while문 안의 조건으로 인해 stack은 탑 높이를 기준으로 내림차순 정렬을 항상 유지하게 된다.
    &lt;ul&gt;
      &lt;li&gt;한번 pop한 요소는 다시 재활용하지 않는다.&lt;/li&gt;
      &lt;li&gt;시간 복잡도를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;으로 줄여줄 수 있는 장점이 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처음에 더미를 스택에 삽입시켜주면, stack이 비어있을 때의 조건을 무시할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;더미 탑 삽입 아이디어를 떠올리는 것이 이 문제의 킥이라고 생각한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2493&quot;&gt;2493) 탑 풀러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 1874) 스택 수열</title>
      <link href="/algo_stack_1" rel="alternate" type="text/html" title="BOJ 1874) 스택 수열" />
      <published>2024-12-15T22:51:00+09:00</published>
      <updated>2024-12-15T22:51:00+09:00</updated>
      <id>/algo_stack_1</id>
      <content type="html" xml:base="/algo_stack_1">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;1부터 n까지의 수를 오름차순으로 스택에 넣었다가 빼는데, 주어진 수열을 만들 수 있는 지 확인하는 문제.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;128&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 12.15.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    int size, num;
    cin &amp;gt;&amp;gt; size;
    stack&amp;lt;int&amp;gt; stk;
    string str; // 출력을 저장하는 이유는 NO 판별시 NO만 출력해야함.

    int i{ 1 };
    while (size--)
    {
        cin &amp;gt;&amp;gt; num;
        while (i &amp;lt;= num)
        {
            str += &amp;quot;+\n&amp;quot;;
            stk.push(i++);
        }
        if (stk.top() == num)
        {
            stk.pop();
            str += &amp;quot;-\n&amp;quot;;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;NO&amp;quot;;
            return 0;
        }
    }

    cout &amp;lt;&amp;lt; str;
    return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/abd4f3955741c1b9757b6d987813b2e9.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;처음에 문제가 이해가지 않아서 꽤나 헤맸지만, 알고보면 쉬운 문제.
    &lt;ul&gt;
      &lt;li&gt;예를 들어 주어진 수열이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3 2 1&lt;/code&gt;이라면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+++&lt;/code&gt;(push 3번)해서 스택을 다 채운 뒤, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;---&lt;/code&gt;(pop 3번)를 해주면 3,2,1이 순서대로 나와서 주어진 수열을 만들 수 있다.&lt;/li&gt;
      &lt;li&gt;하지만 주어진 수열이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3 1 2&lt;/code&gt;이라면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+++&lt;/code&gt;를 해야 3이 먼저 나올 수 있지만, 그러면 1,2 가 순서대로 나오지 않기 때문에 불가능하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1874&quot;&gt;1874) 스택 수열 풀러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">STL stack</title>
      <link href="/algo_stack" rel="alternate" type="text/html" title="STL stack" />
      <published>2024-12-15T21:21:00+09:00</published>
      <updated>2024-12-15T21:21:00+09:00</updated>
      <id>/algo_stack</id>
      <content type="html" xml:base="/algo_stack">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Algorithm &amp;amp; Data Structure &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_tips&quot;&gt;코테 팁 모음&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_array&quot;&gt;Data Structure (1) - Array &amp;amp; STL vector&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_list&quot;&gt;Data Structure (2) - STL list&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_stack&quot;&gt;Data Structure (3) - STL stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;자료구조-3---stl-stack&quot;&gt;자료구조 (3) - STL stack&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-특성&quot;&gt;📌 &lt;strong&gt;특성&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Stack 자료구조의 가장 큰 특징이라면 FILO라고 말할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;쉽게 접시를 위로 점점 쌓는 자료구조라고 생각하면 편한데, 접시를 추가하면 원래 있던 접시 위에 쌓아올려야 할것이고, 뺄때는 맨 위의 접시부터 순차적으로 제거해야할 것이다.
    &lt;ul&gt;
      &lt;li&gt;즉, 가장 먼저 들어간 요소가 가장 마지막에 제거되므로 FILO(First In Last Out) 특성을 지닌다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;늘 원소의 추가와 제거는 마지막 요소를 기점으로 이루어지며, 다른 요소로의 추가, 제거, 접근이 제한된다.(Restricted Structure)&lt;/li&gt;
  &lt;li&gt;deque를 기본 컨테이너로 사용한다.
    &lt;ul&gt;
      &lt;li&gt;컨테이너를 list나 vector로 바꿀 수 있다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex) stack&amp;lt;int,vector&amp;lt;int&amp;gt;&amp;gt; S;&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;값 탐색(Search) - 맨 뒤의 원소(가장 상단)의 값를 확인한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;삽입(Insertion) - 맨 뒤의 원소(가장 상단) 뒤로 요소를 삽입한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;제거(Deletion)- 맨 뒤의 원소(가장 상단)를 제거한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stack&amp;gt;   // STL stack include
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 원소 삽입 1,2,3,4,5,6,7,8,9(top)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// 원소 갯수&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// top 접근&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// stack이 비어있다면 S.empty()는 true&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// top 제거&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* console output:
    9
    9
    9 8 7 6 5 4 3 2 1 
    */&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-활용&quot;&gt;📌 &lt;strong&gt;활용&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;보통 난이도 좀 있는 문제는 Monotoinc Stack 사용(오름차순/내림차순 스택)&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_stack_1&quot;&gt;BOJ 1874) 스택 수열&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_2&quot;&gt;BOJ 2493) 탑&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_2&quot;&gt;BOJ 6198) 옥상 정원 꾸미기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_2&quot;&gt;BOJ 17298) 오큰수&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_2&quot;&gt;BOJ 3015) 오아시스 재결합&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_2&quot;&gt;BOJ 6549) 히스토그램에서 가장 큰 직사각형&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.encrypted.gg/933&quot;&gt;BaaaaaaaarkingDog님의 실전 알고리즘 강좌 0x05강 - 스택&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.encrypted.gg/936&quot;&gt;BaaaaaaaarkingDog님의 실전 알고리즘 강좌 0x08강 - 스택의 활용&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천-링크&quot;&gt;추천 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cplusplus.com/reference/stack/stack/&quot;&gt;stack의 메소드 확인&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Algorithm &amp;amp; Data Structure 코테 팁 모음 Data Structure (1) - Array &amp;amp; STL vector Data Structure (2) - STL list Data Structure (3) - STL stack</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 1158) 요세푸스 문제</title>
      <link href="/algo_list_2" rel="alternate" type="text/html" title="BOJ 1158) 요세푸스 문제" />
      <published>2024-11-27T01:27:00+09:00</published>
      <updated>2024-11-27T01:27:00+09:00</updated>
      <id>/algo_list_2</id>
      <content type="html" xml:base="/algo_list_2">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;N명의 사람이 있으면 남은 사람이 없을때까지 다음 k번째 사람을 매번 탈락시키는 문제. 탈락된 사람의 번호를 순서대로 출력하라.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 11.27.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;numeric&amp;gt;  // for iota
#include &amp;lt;list&amp;gt;
using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int size, k;
    cin &amp;gt;&amp;gt; size &amp;gt;&amp;gt; k;

    list&amp;lt;int&amp;gt; list(size);
    iota(list.begin(), list.end(), 1);
    auto temp = list.begin();
    cout &amp;lt;&amp;lt; &amp;#39;&amp;lt;&amp;#39;;
    while (size--)
    {
        for (int i{ 1 }; i &amp;lt; k; i++)
        {
            temp++;
            if (temp == list.end())
            {
                temp = list.begin();
            }                        
        }
        cout &amp;lt;&amp;lt; *temp;
        temp = list.erase(temp);
        if (list.empty())
        {
            cout &amp;lt;&amp;lt; &amp;#39;&amp;gt;&amp;#39;;
        }
        else
        {
            cout &amp;lt;&amp;lt; &amp;quot;, &amp;quot;;
        }
        if (temp == list.end())
        {
            temp = list.begin();
        }
    }

    return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/7e7a5a277ecdb99e989514d40b966094.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;처음에 총 인원수 만큼 list를 만들고 번호를 매긴다. 이후, list가 빌때까지 k번만큼 temp를 증가시켜주고, 출력한다.&lt;/li&gt;
  &lt;li&gt;temp가 list의 마지막 인자를 넘겼다면, 처음으로 보낸다.&lt;/li&gt;
  &lt;li&gt;예제 출력을 잘 보자. Format을 안지켜서 삽질을 조금 했다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1158&quot;&gt;1158) 요세푸스 문제 풀러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 1406) 에디터</title>
      <link href="/algo_list_1" rel="alternate" type="text/html" title="BOJ 1406) 에디터" />
      <published>2024-11-27T01:16:00+09:00</published>
      <updated>2024-11-27T01:16:00+09:00</updated>
      <id>/algo_list_1</id>
      <content type="html" xml:base="/algo_list_1">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;문자 에디터에 입력된 명령어를 토대로 특정 자리에 문자를 추가하거나 제거해서 결과 문자열을 출력하는 문제.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0.3&lt;/td&gt;
      &lt;td&gt;512&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 11.27.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;list&amp;gt;
using namespace std;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    string text;
    int count;
    cin &amp;gt;&amp;gt; text &amp;gt;&amp;gt; count;
    list&amp;lt;char&amp;gt; list;
    for (char c : text)
    {
        list.push_back(c);
    }

    auto cursor = list.end();
    char c;
    while (count--)
    {
        cin &amp;gt;&amp;gt; c;
        if (c == &amp;#39;L&amp;#39;)//L	move cursor one character to the left (if cursor is at the beginning, do nothing)
        {
            if (cursor == list.begin())
                continue;
            cursor--;
        }
        else if (c == &amp;#39;D&amp;#39;)//D	move cursor one character to the right (if cursor is at the end, do nothing)
        {
            if (cursor == list.end())
                continue;
            cursor++;
        }
        else if (c == &amp;#39;B&amp;#39;)//B	delete character left of the cursor (if cursor is at the beginning, do nothing)
        {
            if (cursor == list.begin())
                continue;
            cursor--;
            cursor = list.erase(cursor);
        }
        else//P $	add character $ right of the cursor (character $ is any lowercase letter of English alphabet)
        {
            cin &amp;gt;&amp;gt; c;
            list.insert(cursor, c);
        }
    }

    for (auto l : list)
    {
        cout &amp;lt;&amp;lt; l;
    }

    return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/5b1edec5ce5401a8afecd5f1d6f967f4.js&quot;&gt; &lt;/script&gt;

&lt;ol&gt;
  &lt;li&gt;처음에는 string과 cursor를 인덱스 취급해서 풀어봤다.(타임아웃)&lt;/li&gt;
  &lt;li&gt;두번째 풀이는 list를 이용하지만 여전히 cursor를 인덱스 취급하여 문자를 추가하거나 제거할때마다 next(list.begin(), cursor)를 해주었다.(타임아웃)&lt;/li&gt;
  &lt;li&gt;마지막으로 list를 이용하면서 cursor를 list의 iterator로 두고 푸니 성공했다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1406&quot;&gt;1406) 에디터 풀러가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/5397&quot;&gt;5397) 키로거 풀러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">STL list</title>
      <link href="/algo_list" rel="alternate" type="text/html" title="STL list" />
      <published>2024-11-27T00:01:00+09:00</published>
      <updated>2024-11-27T00:01:00+09:00</updated>
      <id>/algo_list</id>
      <content type="html" xml:base="/algo_list">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Algorithm &amp;amp; Data Structure &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_tips&quot;&gt;코테 팁 모음&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_array&quot;&gt;Data Structure (1) - Array &amp;amp; STL vector&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_list&quot;&gt;Data Structure (2) - STL list&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./algo_stack&quot;&gt;Data Structure (3) - STL stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;자료구조-2---stl-list&quot;&gt;자료구조 (2) - STL list&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-특성&quot;&gt;📌 &lt;strong&gt;특성&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;List 자료구조의 특성은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;메모리 상 원소들이 불연속해서 할당이 비교적 쉽다.
    &lt;ul&gt;
      &lt;li&gt;배열, STL vector와의 가장 큰 차이점이다.&lt;/li&gt;
      &lt;li&gt;불연속하기 때문에 Cache hit rate가 낮다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;메모리 overhead가 있다.(각 원소들이 단/양방향에 따라 주소를 저장할 공간이 하나/두개 필요하다)&lt;/li&gt;
  &lt;li&gt;임의의 원소 k에 접근(Access) - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;값 탐색(Search) - 첫번째 원소부터 마지막까지 특정 값을 탐색한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;삽입(Insertion) - 앞 뒤로 주소만 이어주면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;제거(Deletion)- 앞 뒤로 주소만 이어주면 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(1)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 Tip:
    list는 삽입 및 삭제 연산이 빈번히 요구되는 작업에 적합하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;-종류&quot;&gt;📌 &lt;strong&gt;종류&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;List의 종류는 크게 세가지로 나눌 수 있다:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;단방향 연결 리스트(Singly linked list) - 각 원소가 다음 원소의 주소를 가지고있음.&lt;/li&gt;
  &lt;li&gt;양방향 연결 리스트(Doubly linked list) - 각 원소가 전 원소와 다음 원소의 주소를 모두 가지고있음.&lt;/li&gt;
  &lt;li&gt;원형 연결 리스트(Circular linked list) - 마지막 원소가 첫 원소의 주소를 가지고있음. 양방향 연결이라면 첫 원소가 전 원소의 주소로 마지막 원소의 주소를 가짐.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;list&amp;gt;   // STL list include
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 원소 10개에 초기값 100&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// O(1) {99,100,100,100,100}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// O(1) {99,100,100,100,101}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// list&amp;lt;int&amp;gt;::iterator&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;//  O(1) {99,50,100,100,100,101} 50을 가리키는 주소 반환&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;erase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// O(1) {50,100,100,100,101} 50을 가리키는 주소 반환&lt;/span&gt;


    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// O(n)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// O(n) loop with iterator&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_1&quot;&gt;BOJ 1406) 에디터&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;./algo_list_2&quot;&gt;BOJ 1158) 요세푸스 문제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.encrypted.gg/932&quot;&gt;BaaaaaaaarkingDog님의 실전 알고리즘 강좌 0x04강 - 연결리스트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천-링크&quot;&gt;추천 링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cplusplus.com/reference/list/list/&quot;&gt;list의 메소드 확인&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cplusplus.com/reference/forward_list/forward_list/&quot;&gt;forward_list의 메소드 확인&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Algorithm &amp;amp; Data Structure 코테 팁 모음 Data Structure (1) - Array &amp;amp; STL vector Data Structure (2) - STL list Data Structure (3) - STL stack</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 1919) 애너그램 만들기</title>
      <link href="/algo_array_2" rel="alternate" type="text/html" title="BOJ 1919) 애너그램 만들기" />
      <published>2024-11-26T23:47:00+09:00</published>
      <updated>2024-11-26T23:47:00+09:00</updated>
      <id>/algo_array_2</id>
      <content type="html" xml:base="/algo_array_2">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;문자의 순서만 바꿔서 같아질수 있는 두 단어를 애너그램 관계에 있다고 한다.&lt;/li&gt;
  &lt;li&gt;두 문자열에서 애너그램 관계가 되도록 제거해야 하는 최소 개수의 문자 수를 구하는 문제.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;128&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 11.26.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;

int arr[26];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    string str1, str2;
    cin &amp;gt;&amp;gt; str1 &amp;gt;&amp;gt; str2;


    for (char c : str1)
    {
        arr[c - &amp;#39;a&amp;#39;]++;
    }
    for (char c : str2)
    {
        arr[c - &amp;#39;a&amp;#39;]--;
    }

    int answer{ 0 };
    for (int n : arr)
    {
        answer += abs(n);
    }

    cout &amp;lt;&amp;lt; answer;

    return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/3b111e29d587943288012cf4ecb95bd0.js&quot;&gt; &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;두 문자열이 가지고 있는 문자들의 갯수가 같으면 애너그램 관계이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 첫 문자열의 알파벳 등장횟수를 배열에 기록 후, 두번째 문자열의 알파벳 등장횟수만큼 배열에서 빼준다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;두 문자열의 관계가 애너그램이라면 배열을 모두 더했을때 0이 될것이고, 차이가 있다면 그만큼이 애너그램 관계를 만들기 위해 제거해야하는 최소한의 문자들의 갯수인 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1919&quot;&gt;1919) 애너그램 만들기 풀러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">BOJ 3273) 두 수의 합</title>
      <link href="/algo_array_1" rel="alternate" type="text/html" title="BOJ 3273) 두 수의 합" />
      <published>2024-11-26T16:14:00+09:00</published>
      <updated>2024-11-26T16:14:00+09:00</updated>
      <id>/algo_array_1</id>
      <content type="html" xml:base="/algo_array_1">&lt;h2 id=&quot;problem-overview&quot;&gt;Problem Overview&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;수열이 주어질때, a+b = x를 만족하는 쌍 수를 구하는 문제이다.(순서는 a가 항상 b보다 빠르다)&lt;/li&gt;
  &lt;li&gt;서로 다른 양의 정수가 들어오기 때문에, 1~100000의 수가 수열에 존재했는지 여부를 알 수 있는 배열과 수열에 들어있는 양의 정수들을 담는 배열이 필요하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;constraints&quot;&gt;Constraints&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;시간 제한(Seconds)&lt;/th&gt;
      &lt;th&gt;메모리 제한(MB)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;128&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;수열의 요소들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 ≤ k ≤ 1000000&lt;/code&gt;인 자연수&lt;/li&gt;
  &lt;li&gt;수열의 크기는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 ≤ n ≤ 100000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;x는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 ≤ x ≤ 2000000&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;noscript&gt;&lt;pre&gt;/*
author: sunwoo.lee
date: 11.26.2024
*/
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;

bool arr[2000001];  // 자연수는 최대 1000000이지만, x는 2000000까지 들어온다. arr[1000001]로 설정 시, 이후 arr[x-num]에서 array out of bound 가능성 있다.
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    int size, num;
    cin &amp;gt;&amp;gt; size;

    int store[100000];  //수열 보관
    for (int i{ 0 }; i &amp;lt; size; i++)
    {
        cin &amp;gt;&amp;gt; num;
        arr[num] = true;
        store[i] = num;
    }

    cin &amp;gt;&amp;gt; num; // num이 x다.
    int answer{ 0 };
    for (int i{ 0 }; i &amp;lt; size; i++)
    {
        if (store[i]&amp;gt;=num || store[i]*2==num) 
            continue;// x가 더 작으면 음수 인덱스 탐색 or arr[num - store[i]]==arr[store[i]] 방지(store=2, x=4이면 자기자신만 확인함)
        if (arr[num - store[i]])  // arr[1000001]로 설정했다면 num - store[i]가 그걸 넘지 않도록 예외 처리해줘야한다.
        {
            answer++;
            arr[store[i]] = false;
        }

    }
    cout &amp;lt;&amp;lt; answer;
    return 0;
}&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/Sunnew-Lee/2b1d27a5fd96012c3ee4c6f994398e3d.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;두가지 edge-case를 확인해야함. 수열의 어떤 요소 k에 대하여,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arr[x-k]&lt;/code&gt;에서 array out of bounds 확인
    &lt;ul&gt;
      &lt;li&gt;x의 값이 2000000까지기 때문에, 첨부터 arr의 크기를 이만큼 설정하던지(arr[1000001]~arr[2000000]까지는 false로 고정일 것임.)&lt;/li&gt;
      &lt;li&gt;따로 인덱스 값이 1000000 이상이면 예외처리를 해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arr[x-k] == k&lt;/code&gt;인 경우에는 무조건 true처리가 돼버린다.
    &lt;ul&gt;
      &lt;li&gt;같을 경우에 예외처리를 해준다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;추천링크&quot;&gt;추천링크&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3273&quot;&gt;3273) 두 수의 합 풀러가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunwoo Lee</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      

      
        <summary type="html">Problem Overview</summary>
      

      
      
    </entry>
  
</feed>
